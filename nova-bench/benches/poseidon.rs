use core::time::Duration;
use criterion::*;
use nova_scotia::{
    circom::reader::load_r1cs, create_public_params, create_recursive_circuit, FileLocation, F1, G2,
};
use nova_snark::traits::Group;
use std::{collections::HashMap, env::current_dir};

criterion_group! {
    name = recursive_snark;
    config = Criterion::default().warm_up_time(Duration::from_millis(3000));
    targets = bench_recursive_snark_proove, bench_recursive_snark_verify
}

criterion_main!(recursive_snark);

fn bench_recursive_snark_proove(c: &mut Criterion) {
    let cases = vec![3, 10, 100];

    let root = current_dir().unwrap();

    // has to be generated by circom before running the code
    let circuit_file = root.join("./examples/poseidon/circom/poseidon_test_nova.r1cs");
    let r1cs = load_r1cs(&FileLocation::PathBuf(circuit_file));
    // has to be generated by circom before running the code
    let witness_generator_wasm =
        root.join("./examples/poseidon/circom/poseidon_test_nova_js/poseidon_test_nova.wasm");

    // Creating public parameters
    let pp = create_public_params(r1cs.clone());

    for k in cases {
        let iteration_count = k;

        let step_in_vector = vec![0, 1, 2, 3];

        // We don't have any private inputs, so corresponding `HashMap`s are empty, thoough we still need to create and pass them
        let mut private_inputs = Vec::new();
        for _ in 0..iteration_count {
            let private_input = HashMap::new();
            private_inputs.push(private_input);
        }

        let start_public_input = step_in_vector
            .into_iter()
            .map(|x| F1::from(x))
            .collect::<Vec<_>>();

        let mut group = c.benchmark_group(format!("Nova-Circom-Poseidon-num-steps-{}", k));
        group.sample_size(10);

        group.bench_function("Prove", |b| {
            b.iter(|| {
                // create a recursive SNARK
                create_recursive_circuit(
                    FileLocation::PathBuf(witness_generator_wasm.clone()),
                    r1cs.clone(),
                    private_inputs.clone(),
                    start_public_input.clone(),
                    &pp,
                )
                .unwrap();
            })
        });
        group.finish();
    }
}

fn bench_recursive_snark_verify(c: &mut Criterion) {
    let cases = vec![3, 10, 100];

    let root = current_dir().unwrap();

    // has to be generated by circom before running the code
    let circuit_file = root.join("./examples/poseidon/circom/poseidon_test_nova.r1cs");
    let r1cs = load_r1cs(&FileLocation::PathBuf(circuit_file));
    // has to be generated by circom before running the code
    let witness_generator_wasm =
        root.join("./examples/poseidon/circom/poseidon_test_nova_js/poseidon_test_nova.wasm");

    let step_in_vector = vec![0, 1, 2, 3];

    // Creating public parameters
    let pp = create_public_params(r1cs.clone());

    println!(
        "Number of constraints per step (primary circuit): {}",
        pp.num_constraints().0
    );
    println!(
        "Number of constraints per step (secondary circuit): {}",
        pp.num_constraints().1
    );

    println!(
        "Number of variables per step (primary circuit): {}",
        pp.num_variables().0
    );
    println!(
        "Number of variables per step (secondary circuit): {}",
        pp.num_variables().1
    );

    for k in cases {
        let iteration_count = k;

        // We don't have any private inputs, so corresponding `HashMap`s are empty, thoough we still need to create and pass them
        let mut private_inputs = Vec::new();
        for _ in 0..iteration_count {
            let private_input = HashMap::new();
            private_inputs.push(private_input);
        }

        let start_public_input = step_in_vector
            .clone()
            .into_iter()
            .map(|x| F1::from(x))
            .collect::<Vec<_>>();

        // create a recursive SNARK
        let recursive_snark = create_recursive_circuit(
            FileLocation::PathBuf(witness_generator_wasm.clone()),
            r1cs.clone(),
            private_inputs.clone(),
            start_public_input.clone(),
            &pp,
        )
        .unwrap();

        let z0_secondary = vec![<G2 as Group>::Scalar::zero()];

        let mut group = c.benchmark_group(format!("Nova-Circom-Poseidon-num-steps-{}", k));
        group.sample_size(10);

        group.bench_function("Verify", |b| {
            b.iter(|| {
                let res = recursive_snark.verify(
                    &pp,
                    iteration_count,
                    start_public_input.clone(),
                    z0_secondary.clone(),
                );
                assert!(res.is_ok());
            })
        });
        group.finish();
    }
}
