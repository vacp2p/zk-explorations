use core::time::Duration;
use std::{collections::HashMap, env::current_dir};
use criterion::*;
use nova_scotia::{circom::reader::load_r1cs, create_public_params, create_recursive_circuit, FileLocation, F1, G2};
use nova_snark::traits::Group;

criterion_group! {
    name = recursive_snark;
    config = Criterion::default().warm_up_time(Duration::from_millis(3000));
    targets = bench_recursive_snark_proove
}
    
criterion_main!(recursive_snark);

fn bench_recursive_snark_proove(c: &mut Criterion) {
    let cases = vec![3, 10, 100];


    let root = current_dir().unwrap();

    // has to be generated by circom before running the code
    let circuit_file = root.join("./examples/poseidon/circom/poseidon_test_nova.r1cs");
    let r1cs = load_r1cs(&FileLocation::PathBuf(circuit_file));
    // has to be generated by circom before running the code
    let witness_generator_wasm =
        root.join("./examples/poseidon/circom/poseidon_test_nova_js/poseidon_test_nova.wasm");

    // Creating public parameters
    let pp = create_public_params(r1cs.clone());


  for k in cases {

    let iteration_count = k;


    let step_in_vector = vec![0, 1, 2, 3];

    // We don't have any private inputs, so corresponding `HashMap`s are empty, thoough we still need to create and pass them
    let mut private_inputs = Vec::new();
    for _ in 0..iteration_count {
        let private_input = HashMap::new();
        private_inputs.push(private_input);
    }

    let start_public_input = step_in_vector
        .into_iter()
        .map(|x| F1::from(x))
        .collect::<Vec<_>>();
    
    let mut group = c.benchmark_group(format!(
      "Nova-Circom-Poseidon-num-steps-{}",
      k
    ));
    group.sample_size(10);

    group.bench_function("Prove", |b| {
      b.iter(|| {
        // create a recursive SNARK
    create_recursive_circuit(
      FileLocation::PathBuf(witness_generator_wasm.clone()),
      r1cs.clone(),
      private_inputs.clone(),
      start_public_input.clone(),
      &pp,
  )
  .unwrap();
      })
    });
    group.finish();
  }
}

